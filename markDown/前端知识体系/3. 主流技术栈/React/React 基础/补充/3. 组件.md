# React 组件

## 创建组件的方式

### 函数式组件

React 在解析所有标签的时候，是以标签的首字母来区分的：如果标签的首字母是小写，就按照普通的 HTML 标签来解析；如果首字母是大写，则按照**组件**的形式来解析。

**结论**：组件的首字母必须大写

#### 父组件传值给子组件

```js
// 父组件中的数据
var person = {
  name: "qianguyihao",
  age: 27,
  gender: "男",
  address: "深圳"
};
// 在子组件中，如果想要使用外部传递过来的数据，必须显示的在 构造数数列表中，定义 props 属性来接收
// 通过 props 得到的任何数据都是只读的，不能重新赋值
function Hello(props) {
  return (
    <div>
      <h3>这是 Hello子组件 中定义的元素： {props.name}<h3>
    </div>
  );
};
ReactDOM.render(
	<!-- 注意：这里的 ...Obj 语法，是 ES6中的属性扩散，表示把这对上的所有属性，展开了，放到这个位置 -->
  <div>
    <Hello {...person}> </Hello>
  </div>,
  document.getElementById("app")
);
```

传递给子组件后，子组件获取的数据仅仅只是可读的。

### 类式组件

面向对象语言的三个特性：封装、继承、多态。多态和接口、虚拟方法有关

使用 `extends` 关键字实现了继承， 子类的 `constructor` 构造函数中，必须显示调用 `super()` 方法，这个 `super` 表示父类中 `constructor` 的引用。

使用 `class` 创建的类，通过 `extends` 关键字，继承 `React.Component` 之后，这个类，就是一个组件的模板了。如果想要引用这个组件，可以把类的名称以**标签的形式**，导入到 JSX 中使用。

#### 父组件传值给子组件

```js
// 使用 class 创建的类，通过 extends 关键字，继承 `React.Component` 之后，这个类，就是一个组件的模板了。
// 如果想要引用这个组件，可以把类的名称以**标签的形式**，导入到 JSX 中使用。
class Hello2 extends React.Component {
  constructor(props) {
    super(props);
    console.log(props.name);

    // 注意：`this.state` 是固定写法，表示当前组件实例的私有数据对象，就好比 vue 中，组件实例身上的 data(){ return {} } 函数
    // 如果想要使用 组件中 state 上的数据，直接通过 this.state.*** 来访问即可
    this.state = {
      msg: "这是 Hello2 组件的私有msg数据",
      info: "永不止步",
    };
  }
  // 在 class 实现的组件内部，必须定义一个 render 函数
  render() {
    // 在 render 函数中，还必须 return 一个东西，如果没有什么需要被return 的，则需要 return null
    return (
      <div>
        <h3>这是使用 class 类创建的组件 </h3>
      </div>
    );
  }
}

ReactDOM.render(
  <div>
    <Hello2 name="uesName"> </Hello2>
  </div>,
  document.getElementById("app")
);
```

### 函数式组件和类式组件对比

- 函数式组件：通过 `function` 构造函数创建**无状态组件**。每部没有 state 私有数据，只有一个 `props` 来接收外界传递过来的数据。
  - 如果一个组件只需要展示数据，使用无状态组件
- 类式组件：通过 `class` 创建**有状态组件**。内部除了有 `this.props`这个**只读属性**外，还有一个专门用于存放私有数据的 `this.state` 属性，这个属性**可读可写**
  - 如果一个组件需要存放私有数据，或需要在不同情况下执行不同业务，使用有状态组件

---

## 生命周期

### 组件创建阶段

> 组件创建阶段的生命周期函数，有一个显著的特点：创建阶段的生命周期函数，在组件的一辈子中，只执行一次。

- `getDefaultProps`：初始化 props 属性默认值。
- `getInitialSate`：初始化组件私有数据。（因为 state 定义在 ；constructor 中，new 后必然后调用 constructor）
- `componentWillMount()`：组件将要被挂载。（此时还没有开始渲染虚拟 DOM，不能操作 DOM 元素，但可以操作属性、状态、function）
- `render()`：第一次开始渲染真正的虚拟 DOM。（**因为 return 之前，虚拟 DOM 还没创建**，虚拟 DOM 在内存中创建好后，但还没挂载到页面上，不能操作 DOM）
- `componentDidMount()`：**当组件（虚拟 DOM）挂载到页面之后，会进入这个生命周期函数**。

### 组件运行阶段

> 有一个显著的特点，根据组件的 state 和 props 的改变，有选择性的触发 0 次或多次。

- `componentWillReceiveProps()`：组件将要接受新属性。（父组件修改了传递给子组件的参数，才会触发这个钩子函数）
- `shouldComponentUpdate()`：判断组件是否需要更新。（组件尚未被更新，但 state 和 props 肯定是最新的）
- `componentWillUpdate()`：组件将被更新。（组件还没更新，在进入这个生命周期时，内存中的虚拟 DOM 还是旧的，页面上的 DOM 元素也是旧的）
- `render()`：根据最新的 state 和 props，重新渲染内存中的虚拟 DOM 树。（调用完毕后，虚拟 DOM 和组件的 state 都是罪行的，但页面还没重新渲染）
- `componentDidUpdate`：此时组件更新完成，页面被重新渲染。（此时 state、虚拟 DOM 和页面已经保持同步）

### 销毁组件阶段

> 只执行一次

- `componentWillUnmount`：组件将被卸载。此时还可以正常使用。

### 组件生命周期执行顺序

- Mounting:
  1. `constructor()`
  2. `componentWillMount()`
  3. `render()`
  4. `componentDidMount()`
- Updating:
  1. `componentWillReceiveProps(nextProps)`：接受父组件传递过来的参数
  2. `shouldComponentUpdate(nextProps,nextState)`：一旦调用 setState，就会触发这个方法。方法默认 `return true`；如果 `return false`，后续的方法就不会走了。
  3. `componentWillUpdate(nextProps,nextState)`
  4. `render()`
  5. `componentDidUpdate(prevProps,prevState)`
- Unmounting
  1. `componentWillUnmount()`
