# 一. 前端基础

## 1. html

### 1.1 语义化

它存在的意义，就是让前端开发人员，在开发过程中，更容易去阅读代码，以及明白这些代码的意义。

1. 能够更好的展示内容结构
2. 便于团队的维护与开发
3. 有利于 SEO，爬虫可以分析每个关键词的权重。
4. 方便其他设备解析 (如屏幕阅读器)

### 1.2 SEO

作为前端，你不得不知道的 SEO，这涉及到公司的网站推广。

SEO，中文称搜索引擎优化，一种利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的自然排名的方式。他的实现原来分别为，页面抓取，分析入库，检索排序。

### 1.3 doctype

前端经常在 html 头部看到 DOCTYPE 的声明，一般常位于文档的第一行。

DOCTYPE 的存在，就是为了声明，该页面使用标准模式。不声明，可能一些旧的网站会出现兼容模式。

### 1.4 link 与@import

link 与 import , 本质使用上，我们都是用他来引入 css，但是他们有一定的区别：

1. 资源：link 是一种引入**资源**的标签，import 是引入 css 的方式。所以，import 引入的只能是 css，而 link 可以引入所有的资源，包括图片，RSS 等。

2. 兼容性：兼容性的差别。 link 无任何兼容问题，import 兼容 IE5 以上。（当然，IE5 估计也找不到了）

3. 加载顺序：加载顺序上也有一些差异。 link 引用的 CSS 会同时被加载。 import 引用的 CSS 会等到页面全部被下载完再加载。

4. 加载方式：动态引入样式 link 可以后期引入样式，而 import 是不可以后期引入的，只能初始化页面之前引入。

5. 复用率：复用率的问题 import 可以复用之前的 css 文件，而 link 只能一次引用一个文件。 当然，import 复用文件时，在浏览器实际上是加载了多个文件，会有多个请求。而每一个 link 只是一个 http 请求。

### 1.5 async 与 defer

首先这两个东西为什么而存在的问题。在日渐复杂的前端，异常已经是程序的一部分。如果出现一些小问题，或者服务器加载上出现延迟。而我们默认的引入的 script 脚本，会**阻塞后续的 DOM 渲染**。一旦没有部分异常无法及时加载完成，那么我们的页面因为阻塞问题，将整个白屏。

也许我们可以保证自己服务器的正常，但是你决定保证不了第三方服务器的正常，于是引入了 `async` 和 `defer` 来优化这个问题。

script 的默认、`async`、`defer` 的之间的差异:

- **默认情况下**： 浏览器会立即加载并执行在 script 标签之上的脚本。所以，如果 script 放在 header 中，而对应的文件还未加载完成，会形成阻塞。所以这就是现在很多页面，都会使用默认且把 script 放在页面结尾的原因。

- **async 情况下**： async ，加载和渲染后续文档元素的过程将和 script.js 的加载与**执行并行进行（异步）**。async 是乱序的。

- **defer 情况下**： defer，加载后续文档元素的过程将和 script.js 的**加载并行进行（异步）**，但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。defer 是顺序执行

此外，async 跟 defer，不支持或者不兼容 IE9 一下浏览器，总体来说，还是 script 放最下方靠谱一些。

### 1.6 文本元素的冒泡与委托

适合用事件委托的事件：`click`，`mousedown`，`mouseup`，`keydown`，`keyup`，`keypress`。

#### 优点：

1. 减少事件注册，节省内存。例如上面代码，只指定 父元素的处理程序，即可管理所有所有子元素的`click`事件；
2. 简化了 dom 节点更新时，相应事件的更新

#### 缺点：

1. 利用事件冒泡的原理，不支持不冒泡的事件；

2. 层级过多，冒泡过程中，可能会被某层阻止掉；

3. 理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理。所以建议**就近委托**，比如在 ol 上代理 li，而不是在 document 上代理 li。

4. 把所有事件都用代理就可能会出现事件误判。比如，在 document 中代理了所有 button 的 click 事件，另外的人在引用改 js 时，可能不知道，造成单击 button 触发了两个 click 事件。

## 2. CSS

### 2.1 盒子模型

个人的理解，就是一个 html 标签,组成盒子的内容包括从内至外： `content`+`padding`+`border`+`margin`。

#### 盒模型分两类：

- W3C 盒子模型：可通过 `box-sizing: content-box` 来设置，他包含 content+padding+border+margin。
- IE 盒子模型：可通过 `box-sizing: border-box` 来设置，content+margin。其中 content 包含 border，padding。

### 2.2 BFC

简单的个人理解，block formatting context，块级格式化上下文。产生了 BFC 的，形成了独立容器，他的特性就是不会再布局中影响到外边的元素。

#### 特性：

1. BFC 边距会重叠。
2. BFC 的内外元素互相不影响
3. BFC 不会与浮动元素发生重叠
4. BFC 元素的高度计算会包括元素内的浮动元素的高度

#### 触发的条件是：

1. `body` 根元素
2. 浮动元素：`float` 除 `none` 以外的值
3. 绝对定位元素：`position` 的值为`absolute`或`fixed`
4. `display` 为 `inline-block`、`table-cells`、`flex`、`table-caption`
5. `overflow` 除了 `visible` 以外的值 (`hidden`、`auto`、`scroll`)

此外，除了 BFC，还有 IFC、GFC、FFC 的概念。

- GFC：可简单理解为 grid 布局
- FFC：可简单理解为 flex 布局。
- IFC：内联格式化上下文，简单理解为：`inline-block`。

水平方向上的 margin，border 和 padding 在框之间得到保留。框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐。包含那些框的长方形区域，会形成一行，叫做行框。inline-block 的元素的内部是一个 BFC，但是它本身可以和其它 inline 元素一起形成 IFC。

### 2.3 flex 布局

flex，即弹性布局。一个由 **css3 引入**，为我们的盒子属性带来灵活性的一种布局方式。一旦父级采用了 flex 布局，里边的子控件将收 flex 布局限制，部分原本的样式（如 float:left）也会失效。

### 2.4 css3 新特性

- 背景，支持 RGBA 透明度，一次多背景图
- 支持媒体查询
- 支持阴影，渐变，阴影
- 支持边框图片，`border-image: url(border.png) 30 30 round`
- 支持`transform`位移系列
- 支持过渡效果`transition`
- 支持自定义字体
- 引入 flex/grid 布局
- 引入多种选择器
- 等等……

### 2.5 图片格式

前端的图片分类格式,其实是性能优化的很大部分。选择好图片的类型，对前端的性能影响非常大。

而前端对图片的精髓，一方面是对图片**大小**的评估，一方面是对图片的**类型**选择。

他的大小可以这样判断：

比如一张 200\*200 的图片大小，这时候，他的像素点有 40000 个。每个像素有 4 个通道， 所以一共有 160000 个字节,所以，我们评估该图片的大小大概为：160000/1024 约等于 156（KB）， 如果大很多，说明图片大小有优化控件。如果小很多，说明此时是模糊的。

| 图片类型 | 介绍                                                               | 使用场景                                                           |
| :------- | :----------------------------------------------------------------- | :----------------------------------------------------------------- |
| png      | 适合颜色简单，但是对图片质量比较高。日常用的 png8，此外还有 png32, | 适合 logo 体积太大一般不用                                         |
| jpeg     | 不影响图片质量的情况有损压缩，banner 图。适合大图。                |                                                                    |
| svg      | 对性能有损耗，体积小，压缩性强。可在质量不下降的过程被放大         | 部分浏览器兼容性不太好                                             |
| webp     | 只针对谷歌，兼容性不好。图片大小能压缩 30~40%。                    | 谷歌浏览器用，如有非常注重性能的产品，可判断浏览器加载不同类型图片 |
| base64   | 压缩成字符流，实际大小是变大了，但是好处就是减少了 http 请求       | 一般也针对小图标                                                   |

### 2.6 移动端适配

- **媒体查询**：该方案的话，个人觉得是最佳的方案，也是常用 UI 库非常喜欢的用处理方式之一。唯一不好的是：多套媒体方案，也意味多份的工作量。

- **vw/vh**：利用单位 vw/vh 进行布局。该方案的话，对整体的布局还是相对稳定，但是对部分细节等处理还是不优化。且遇到手机屏幕差异较大的话，会出现严重的视差

- **rem**：相对稳定的方法。根据屏幕大小计算出 font-size;但是只能求良好，很难求精。如果 UI 对一像素非常的敏感，这个方案可能是个非常糟糕的选择。

- **类似小程序 rpx**：相信原生小程序开发者都用过 rpx。这里其实原理有点类似 rem。但是，却不是按屏幕大小去计算，而是不同的屏幕定义了自己的标准。

### 2.7 常见兼容性

本次只列举了几个常见的，非全部列出。如需具体，可另查资料。

- 间距差异是否大，导致文本换行，或者间隔太大。 原因：每个浏览器的 `margin` 和 `padding` 的默认值不同。 解决方案：全局文件设置统一默认 `margin` 和 `padding。`

- 图片默认有间距，原因：因为 img 标签是行内属性标签，所以只要不超出容器宽度，img 标签都会排在一行里，但是部分浏览器的 img 标签之间会有个间距。去掉这个间距使用 `float` 是正道。（我的一个学生使用负 `margin`，虽然能解决，但负 `margin` 本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用）解决方案：使用 `float` 属性为 img 布局

- 较小的高度（小于 10px），时，ie 可能会超出高度 原因：IE 有一个默认的行高的高度 解决方案：给超出高度的标签设置`overflow:hidden`;或者设置行高`line-height`小于你设置的高度。

- 透明度兼容设置 原因：不同浏览器各自透明度关键字不统一。 解决方案：`filter:alpha(opacity=50); -moz-opacity:0.5; -khtml-opacity: 0.5; opacity: 0.5;`

- IE 的 `hover` 图片会闪烁 原因：IE6 的每次触发 `hover` 的时候都会重新加载 解决方案：提前缓存文件。`document.execCommand("BackgroundImageCache", false, true)`;

### 2.8 垂直居中

给予思路，没有具体写法。因为我觉得大家都应该懂。

已知宽高： 1.margin 自己算高宽　 2.定位 + margin-top + margin-left 3.定位 + margin:auto

未知宽高： 1.transform 但有 IE 兼容的问题 2.flex 布局 3.display: table-cell

### 2.9 实现 1px

首先你可能需要了解一下物理像素跟独立像素的区别。

- 物理像素： 一个物理像素是显示器（手机屏幕）上最小的物理显示单元，如：iPhone6 上就有 7501334 个物理像素颗粒。
- 独立像素：逻辑像素，程序使用的虚拟像素。如：iPhone6 上就有 375677 个独立像素。

那么如何实现 1px 呢：

1. 利用 `transform` 的 `scale` 缩放来实现
2. 利用 `background` 的 `line-gradient` 线性渐变来实现
3. `meta viewport` 修改成 1 比 0.5。这样整个屏幕的大小缩小了 0.5。
4. 利用 `box-shadow`

### 2.10 三列布局

给予思路

1. CSS 浮动：第一个 float:left，第二个 float:right，第三个设置 margin-left 和 margin-right
2. 绝对定位法：第一个定位到 left，第二个定位到 right，第三个设置 margin-left 和 margin-right
3. flex 布局

### 2.11 样式优化

1. 避免 css 层级太深。有兴趣了解一下 css tree 如何跟 html tree 融合成 dom tree。
2. 首屏（特别是缓冲效果图）可适当使用内联元素。这样有利于更快的显示。
3. 异步加载 CSS。非首次重要引入的 css 文件，不放在 head 里边。这样会引起阻塞。
4. 减少 回流 的属性。如 `display:none` 可以考虑使用 `visibility`
5. 适当使用 GPU 渲染。如 `transform` 等。
6. css 动画的性能，是远远的大于 js 动画性能。
7. 利用工具压缩，去重。

## 3. JavaScript

### 3.1 内置对象

内置对象，也叫原始类型。

原始类型有 5 个：

- `null`
- `undefined`
- `boolean`
- `number`
- `string`

es6 引入了 `symbol`，可以用来做独立标识用。 es10 引入了 `bigint`， 主要用的大数据。`number` 最大值 2 的 53 次方，超过只能使用 `bigint`。 截至目前为止，一共是 7 个。

原始类型存储的都是**值**，他的原型汇总，是没有任何函数的。如果你看到类型有函数，比如 `toString`，那说明类型给转换为了对象类型，此时才有 `toString` 方法。

原始类型存储的是**值**，对象类型存储的是**地址**。

### 3.2 闭包

简单的理解是，一个绑定了执行环境的函数，可以访问到外部环境的变量。

优点：变量常驻内存，对于实现某些业务很有帮助，比如计数器之类的。 架起了一座桥梁，让函数外部访问函数内部变量成为可能。 私有化，一定程序上解决命名冲突问题，可以实现私有变量。

缺点：他的变量常驻在内存中，其占用内存无法被 GC 回收，导致内存溢出。

注意，闭包的原理是作用域链，所以闭包访问的上级作用域中的变量是个对象，其值为其运算结束后的最后一个值。

### 3.3 执行上下文

代码运行时，产生一个对应的执行环境，这个叫做执行上下文。通常执行上下文，有三个环境：

1. 全局环境：代码首先进入的环境
2. 函数环境：函数被调用时执行的环境
3. [eval 函数](https://www.cnblogs.com/chaoguo1234/p/5384745.html)：eval 函数接收一个由 JavaScript 语句组成的字符串，并且返回字符串中最后一条语句的返回值，如果最后一条语句没有返回值，那么 eval 函数返回 undefined。如果传递给 eval 函数的不是字符串，那么传递什么，eval 就返回什么。

执行上下文，可分为三个阶段，分别为创建，执行，销毁阶段。我们简单的分析一下，各个阶段分别处理了什么。

- 创建阶段：(1).生成变量对象；(2).建立作用域链；(3).确定 this 指向
- 执行阶段：(1).变量赋值；(2).函数引用；(3).执行其他代码
- 销毁阶段： 执行完毕出栈，等待回收被销毁

### 3.4 原型/原型链

指构造函数的内置属性，即 prototype 属性。每个构造函数都自带 prototype 属性，指向一个对象，常用实例共享属性和方法的。

`Prototype.constructor` 会指向原构造函数

对象的原型，也是个对象。只要对象的原型有值，不为 null，他就还有原型。所以构成了原型链。

### 3.5 作用链域

作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。

_（注意：JS 没有块级作用域，若要形成块级作用域，可通过（function（）｛｝）（）；立即执行的形式实现。）_

### 3.6 继承

继承的几种方式:

1. **原型链继承** 本质是重写了对象。

   1. 缺点：
      1. 对象实例共享所有继承的属性和方法
      2. 不能传递参数

2. **构造函数继承** 在子类构造函数的内部调用超类型构造函数。使用 `apply()`和`call()`方法。
   1. 缺点：
      1. 函数复用性不高
      2. 只能继承实例上的属性，原型上的方法不可见
3. **组合继承** 本质：原型链　＋　构造函数 `Parent.call(this)` `new Parent()`避免了上述的缺点，常用。
   1. 优点：可传参，不会与父类引用属性共享
   2. 缺点：继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。
4. **原型式继承** 实现本质：`object()`函数对传入其中的对象执行了一次浅复制
5. **寄生式继承** 借用构造函数来继承属性，通过原型链的混成形式来继承方法
6. **寄生组合** 高效率只调用了一次构造函数，集寄生式继承和组合继承的优点于一身，是实现基于类型继承的最有效方式。 就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题 `Parent.call` + `Object.create()`
7. **class 继承**

### 3.7 this 关键字

1. `this` 总是指向函数的直接调用者（而非间接调用者）
2. 如果有 `new` 关键字，`this` 指向 `new` 出来的那个对象
3. 在事件中，`this` 指向目标元素，特殊的是 **IE** 的 `attachEvent` 中的 `this` 总是指向全局对象 `window`。

this 大概有以下五种场景：

1. 绑定事件指向事件本身
2. 普通函数的，指向方法体。
3. `new` 函数的指向当前类
4. 箭头函数，指向上级上下文
5. `call`/`apply`/`bind`

### 3.8 new 关键字

看以下代码，这就是 new 的整体过程。

```js
function createThis(proto) {
  var obj = new Object();
  obj.__proto__ = proto.prototype;
  let [constructor, ...args] = [...arguments];
  let result = constructor.apply(obj, args);
  return typeof result === "object" ? result : obj;
}
```

可以从代码中看到 `new` 的执行过程，新建一个对象，设置原型链，改变 `this` 指向，根据对象返回结果。

### 3.9 类型的判断

谈到 js 类型的判断，我们能想起 `typeof`，`instanceof`，`constructor`，`Object.__proto__.toString.call()`。

他们的作用与区别:

- **typeof** 对于原始类型来说，除了 `null` 都可以显示正确的类型。但是对于对象来说，除了函数都会显示 `object`，所以他的作用，仅仅只能判断原始类型，判断不了对象。

- **instanceof**，用于判断一个变量是否某个对象的实例，内部机制是通过原型链来判断的。他的确能判断是否类型的是否正确。但一点值得注意，`instanceof` 检测的是原型，原型链上，每一个类型，都会返回 `true`。所以，只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。
- **constructor**, 是原型 `prototype` 的一个属性，当函数被定义时候，js 引擎会为函数添加原型 `prototype`，并且这个 `prototype` 中 `constructor` 属性指向函数引用， 因此重写 `prototype` 会丢失原来的 `constructor`。
  - 但是他也有明显的**缺陷**：
    1. `null` 和 `undefined` 无 `constructor`，这种方法判断不了。
    2. 还有，如果自定义对象，开发者重写 `prototype` 之后，原有的 `constructor` 会丢失，因此，为了规范开发，在重写对象原型时一般都需要重新给 `constructor` 赋值，以保证对象实例的类型不被篡改。
- **toString** 是几个方案中，相对比较不错的方案。建议使用。`toString()` 是 Object 的原型方法，调用该方法，默认返回当前对象的 `[Class]` 。这是一个内部属性，其格式为 `[object Xxx]` ，其中 `Xxx` 就是对象的类型。

### 3.10 类型的转换

js 类型的转换，可以分为三种情况：

- 转换为布尔值
- 转换为数字
- 转换为字符串

其中，转化为 `boolean`，除了 `undefined`， `null`， `false`，`NaN`， `''`，`0`， `-0`，其他所有值都转为 true。我们日常可以用它来判断对象是否未赋值。

### 3.11 比较运算符

比较运算符，是我们常用到的。如果都为 `number` 类型，比较值的大小，那么当然简单咯。如果是非 `number` 值的时候如何处理呢？

顺序如下： 将值转换为原始值（ToPrimitive 方法） 转换为数字（valueOf 方法） 转换为字符串（toString 方法）

### 3.12 四则运算符

分为两类：

1. 加法类： 只要有运算有字符串，那么将全部转为字符串。 如果不是字符串（且数字），那就把它转换为（字符串）或数字。
2. 非加法类： 只要其中一方是数字，那么另一方就转为数字。

### 3.13 拷贝

拷贝，任何语言都有自己的**深拷贝**以及**浅拷贝**。深拷贝有利于**数据的完全独立**，但是全是深拷贝的话，内存又不会不断的往上涨，于是又有了浅拷贝。

- **浅拷贝**指拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响。
- **深拷贝**完全拷贝一个新对象，修改时原对象不再受到任何影响

如何实现深拷贝：

- 可以使用 `JSON.parse(JSON.stringify(obj))`。性能最快。其弊端也必将明显，首先无法拷贝**函数**、**undefined**、或 **symbol** 等值。其二对象要是有自身循环调用，会报错。
- 利用**递归**来实现每一层都重新创建对象并赋值
- 如何用 jquery，可以考虑，`$.extend( [deep ], target, object1 [, objectN ] )`，这也是深拷贝的一种。
- 也可以利用 **lodash.js**，**cloneDeep** 方法进行深拷贝。

### 3.14 函数调用

js 的函数调用，有四种方式：

1. 方法调用模式（this 指向他本身）
2. 函数调用模式（this 指向 windows）
3. 构造器调用模式（利用原型构造，JS 摒弃这个方法）
4. apply 调用模式（利用 apply 改变 this 对象。）

### 3.15 高阶函数

接收函数作为参数或者返回函数的函数，都可成为高阶函数。 所以常见的方法有：`map`,`filter`,`bind`,`apply` 等。

需要了解一下，高阶函数实现 **AOP**。

### 3.16 柯里化函数

柯里化，实现上，就是返回一个**高阶函数**，通过**闭包**把传入的参数保存起来。当传入的参数数量不足时，递归调用 `bind` 方法；数量足够时则立即执行函数。学习一下 javascript 的高阶用法还是有意义的。

**柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。**

### 3.17 数组

[数组详解](https://juejin.im/post/6844903917705232397)

### 3.18 伪数组

伪数组，说明它不是真正意义上的数组，他的输出是个对象，但他的原型并不指向 Array。

常见的伪数组包括：`arguments`、`getElementsByTagName` 等获取的 **NodeList 对象**

它的特性是：

- 具有 length 属性；
- 按索引方式存储数据；
- 没有内置方法，不具有数组的 `push()`、`pop()`等方法

伪数组也可以转换为数组，可以通过

- `var args = Array.prototype.slice.call(arguments);`
- `Array.from(arguments)`
- 扩展运算符

### 3.19 重定向 this

`call`,`apply`,`bind`，三者都是用来改变函数的 this 对象的指向的。且第一个参数都是 `this` 要指向的对象，也就是想指定的上下文。

但传参的值也不同，`apply` 后续只能传递数组，而 `call` 与 `bind` 可以传递多个参数。

`bind` 是返回对应函数，便于稍后调用；`apply`、`call` 则是立即调用。

### 3.20 严格模式

use strict 是否很熟悉？了解一下他的大概作用：

1. 消除 js 不合理，不严谨地方，减少怪异行为
2. 消除代码运行的不安全之处，
3. 提高编译器的效率，增加运行速度
4. 为未来的 js 新版本做铺垫。

### 3.21 循环

首先效率问题： `for` > `forEach` > `map`

如何选择对应的循环呢：

- 如果需要将数组按照某种规则映射为另一个数组 `map`
- 如果需要进行简单的遍历 `forEach` 或者 `for of`
- 如果需要对迭代器进行遍历 `for of`
- 如果需要过滤出符合条件的项 `filter`

`for…of` 和 `for`的区别：

这个 `for-of` 循环首先调用了 `values` 数组的 `Symbol.iterator` 方法，获取了一个迭代器
（对 `Symbol.iterator` 的调用发生在 JS 引擎后台）。接下来 `iterator.next()` 被调用，迭
代器结果对象的 `value` 属性被读出并放入了第一个结果变量。
如果你只是简单地迭代数组或集合的值，那么使用 `for-of` 循环而不是 `for` 循环就是个好
主意。 `for-of` 循环一般不易出错，因为需要留意的条件更少；传统的 `for` 循环被保留用
于处理更复杂的控制条件。在不可迭代对象、 `null` 或 `undefined` 上使用 `for-of` 语句，会抛出错误。

# 二. 前端基础进阶

## 1. ES6

### 1.1 模块化

在以前，js 一直没有模块化的体系。这就会产生一个问题，当项目到达大型时，很大可能性出现方法重叠，以及安全性问题，成为大型项目的一个痛点与障碍。而 es6 模块化正式为此诞生。

这里简述前端模块化的区别：

1. **AMD**, **commonJS**， 与 **es6**，都属于**预加载类型**。而后期引入的 **CDM** 是**懒加载**。 何为预加载， 也就是说，在程序调用，所有的模块都加载完成。 而懒加载，是用到什么的时候，才去加载什么。

2. **AMD** 跟 **CMD** 专注于前端的规范。而 **commonjs** 跟 **es6 module** 可用于前后端。
3. **AMD** 的代表做为 **requirejs**，**CMD** 的代表作为 **seajs**。**commonjs** 与 **es6**，则无需引入，只需要引入编译器(如 babel)即可。 **seajs** 为淘宝引入的规范，我们都知道淘宝相对很大，不采用懒加载，首屏的时间将会很长，不过现在已经停止维护。
4. **es6** 跟 **commonJS**做了如下改变：

   1. ES6 只能新增值，无法重新赋值就会报错

   2. CommonJS 输出是值的拷贝，即原来模块中的值改变不会影响已经加载的该值， ES6 静态分析，动态引用，输出的是值的引用，值改变，引用也改变，即原来模块中的值改变则该加载的值也改变。
   3. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
   4. CommonJS 加载的是整个模块，即将所有的接口全部加载进来， ES6 可以单独加载其中的某个接口（方法）。
   5. CommonJS `this` 指向当前模块，ES6 `this` 指向 `undefined`

### 1.2 变量声明

变量声明`var`会有变量提升。变量会提前初始化，也可以提前访问。当项目变量复杂的时候，很容易产生 bug。es6 就在这个时候，引入了 `let` 跟 `const`。

当然，引入 `let` 与 `const` 不仅仅解决了变量提升的问题，他们的不同如下：

1. **局部作用域** 新引入的 `let`，`const` 声明，再不会再产生变量提升。避免了变量提前访问的场景，间接的提高了严谨性。我们可以在程序运行时就知道了报错，而非后期的调试中。

2. **禁止重复声明** 如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 `let` 声明就会导致抛出错误
3. **区分常量与变量** 这是 `let` 与 `const` 的区别。`const` 声明会阻止对于变量绑定与变量自身值的修改，避免了我们日常开发中，了不小心改到常量的问题。
4. **暂时性死区**

### 1.3 Symbol

`Symbol` 是 JS 新引入的基本类型。我们都知道在 ES5 之前，JS 已有的基本类型（字符串、数值、布尔类型、 null 与 undefined ）之外， ES6 引入 了一种新的基本类型。

符号起初被设计用于创建对象私有成员，而这也是 JS 开发者期待已久的特性。
在符号诞生之前，将字符串作为属性名称导致属性可以被轻易访问，无论命名规则如何。而“**私有名称**”意味着开发者可以创建非字符串类型的属性名称，由此可以防止使用常规手段来探查这些名称。

我们常用于：

1. 作为内置属性名称。可以避免同参数名的覆盖。
2. 使用 Symbol 来替代常量。Symbol 来创建一些常量。比如订单状态等，可以也可以避免重复。

### 1.4 数组的扩展

需要明白 `Array.of` 跟 `Array.form` 的意义。

首先上述提到，数组有了伪数组的概念，而转化为数组，可以通过 `Array.prototype.slice.call(arguments)`。但是这个方法并不直观，所以引入了更为直观的 `Array.form`。

只要是部署了 `iterator` 接口的数据结构，`Array.from` 都能将其转为数组。

而 `Array.of` 是为了解决 `new Array()`的严谨性的问题。 `new Array()`后边的值，可能代表长度，可能代表数值。

`Array.of` 基本上可以用来替代 `Array()`或 `new Array()`，并且不存在由于参数不同而导致的重载，而且他们的行为非常统一。

### 1.5 函数的扩展

es6 对函数的扩展，主要针对两个，一个是**箭头函数**，一个是**解构函数**。

箭头函数跟普通函数的区别：

1. 用了箭头函数，`this` 就不是指向 window，而是父级(指向是可变的)。
2. 不能使用 `arguments` 对象。
3. 不能用作构造函数，这就是说不能够使用 `new` 命令，否则会抛出一个错误。
4. 不可以使用 `yield` 命令，因此箭头函数不能用作 `Generator` 函数

### 1.6 Map，Set，WeakMap 与 WeakSet

数组在 JS 中的使用正如其他语言的数组一样，但缺少更多类型的集合导致数组也经常被当作队列与栈来使用。 数组只使用了数值型的索引，而如果非数值型的索引是必要的，开发者便会使用非数组的对象。

#### Map

`Map` 与 `Object`，其最本质的区别，键值对的集合（Hash 结构），但是传统上只能用字符串当作键。对于 Map 来说，undefined 和 null 是两个不同的键，布尔值 true 和字符串 true 是两个不同的键，而 NaN 之间视为同一个键 ，0 和-0 也是一个键，

```js
const map = new Map();
map.set(["a"], 1);
map.get(["a"]);
```

会输出 `undefined`。

#### WeakMap

`WeakMap` 跟 `Map` 结构类似，也是用于生成键值对的集合,但是他只能用对象，来作为键值。其次，WeakMap 的键名所指向的对象，**不计入垃圾回收机制**。

WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有 keys()、values()和 entries()方法），也没有 size 属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持 clear 方法。因此，WeakMap 只有四个方法可用：`get()`、`set()`、`has()`、`delete()`。

WeakMap 的实例比较少，个人从来没有在实践中使用。但有这么一个实例相对适合：**比如我们要统计一个页面统计该页面所有节点的点击次数**。

1. 首先我们获取到的 dom 是一个对象，符合作为键值。
2. 当对应的节点消失的时候，垃圾回收机制，回自动回收对应的在 WeakMap 节点，同时达到释放内存的目的

#### Set

Set 可能相对更好理解，他可以简单理解为是一个“无重复值”的“有序”列表，且运行值方便快速访问以及判断。

我们可以利用他去重。包括数组，字符串等。

也可以利用他去接受一些具有 iterable 接口的其他数据结构，例如我们统计页面有几个 div? `new Set(document.querySelectorAll('div'))`;

#### WeakSet

跟 WeakMap 类似，还是两个关键字：“对象”，“内存”

### 1.7 iterator

迭代器 `iterator`, 可以理解成一个为不同的数据结构，统一访问的机制（`Symbol.iterator` 属性）。只要对应的数据结构有 `Symbol.iterator` 属性，就可以完成遍历操作。

```js
function createIterator(items) {
  var i = 0;
  return {
    next: function() {
      var done = i >= items.length;
      var value = !done ? items[i++] : undefined;
      return {
        done: done,
        value: value
      };
    }
  };
}
var iterator = createIterator([1, 2, 3]);
console.log(iterator.next()); // "{ value: 1, done: false }"
console.log(iterator.next()); // "{ value: 2, done: false }"
console.log(iterator.next()); // "{ value: 3, done: false }"
console.log(iterator.next()); // "{ value: undefined, done: true }"
```

我们的字符串，数组、类数组的对象、Set 和 Map，都具备 Iterator 接口。所以他们都是可迭代对象。

可迭代的作用有三个：

1. 为各种数据结构，提供一个统一的、简便的访问接口；
2. 是使得数据结构的成员能够按某种次序排列；
3. 是 ES6 创造了一种新的遍历命令 for...of 循环，Iterator 接口主要供 for...of 消费。

常用到 iterator 的场景包括：

1. for...of 循环
2. 扩展运算符
3. 解构赋值
4. yield_yield 后面跟的是一个可遍历的结构
5. 数组的遍历会调用遍历器接口

### 1.8 Generator

严格来说 `generator`（生成器）属于 ES5，并不是 ES6。但由于涉及迭代器等，所以并入 es6 模块。

生成器（ `generator` ）是能返回一个迭代器的函数。生成器函数由放在 `function` 关键字之后的一个星号（ \* ）来表示，并能使用新的 `yield` 关键字。将星号紧跟在 `function` 关键字之后，或是在中间留出空格，都是没问题的

形式上，`Generator` 函数是一个普通函数，但是有两个特征。一是，`function` 关键字与函数名之间有一个星号；二是，函数体内部使用 `yield` 表达式，定义不同的内部状态（yield 在英语里的意思就是“产出”）。

`Generator` 有着"停止"，"开始"的状态，那我们可以用他来控制异步编程，所以，他也是异步的解决方案之一。

`Generator` 要 `next` 一步一步往下执行。如果想一步执行，可以借助 `Thunk` 函数（当然他的原理也是遍历帮我们执行了 next。）

### 1.9 Promise

`Promise` 被设计用于改善 JS 中的异步编程，与事件及回调函数对比，在异步操作方面为你提供了更多的控制权与组合性。 `Promise` 调度被添加到 JS 引擎作业队列，以便稍后执行。不过此处有另一个作业队列追踪着 `Promise` 的完成与拒绝处理函数，以确保适当的执行。

`Promise` 具有三种状态：**挂起**、**已完成**、**已拒绝**。一个 `Promise` 起始于挂起态，并在成功时转为完成态，或在失败时转为拒绝态。在这两种情况下，处理函数都能被添加以表明 Promise 何时被解决。

Promise 的缺陷：

1. 无法取消 `Promise`，一旦新建它就会立即执行，无法中途取消。
2. 如果不设置回调函数，`Promise` 内部抛出的错误，不会反应到外部。
3. 当处于 `pending` 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
4. `then` 的写法相比 `await`，明显在程序代码抒写上，更加繁琐。

### 1.10 proxy 跟 Reflect

#### proxy

proxy 代理对目标对象进行了**虚拟**，因此该代理与该目标对象表面上可以被当作同一个对象来对待。代理允许你拦截在目标对象上的底层操作，而这原本是 JS 引擎的内部能力。拦截行为使用了一个能够**响应特定操作的函数**（被称为陷阱）。

#### Reflect

Reflect 是给底层操作提供默认行为的方法的集合，这些操作是能够被代理**重写**的。每个代理陷阱都有一个对应的**反射方法**，每个方法都与对应的陷阱函数同名，并且接收的参数也与之一致。

JS 运行环境包含一些不可枚举、不可写入的对象属性，然而在 ES5 之前开发者无法定义他们自己的不可枚举属性或不可写入属性。 ES5 引入了 `Object.defineProperty()` 方法以便开发者在这方面能够像 JS 引擎那样做。

ES6 让开发者能进一步接近 JS 引擎的能力，这些能力原先只存在于内置对象上。语言通过代理（ `proxy` ）暴露了在对象上的内部工作，代理是一种封装，能够拦截并改变 JS 引擎的底层操作。

### 1.11 Class 写法

Class 写法，可以简单理解成 ES6 的一个语法糖。我们日常用他所实现的功能，其实用 ES5 都可以做到，但是 class 的写法，让对象原型的写法更加清晰。 但不仅仅是糖语法。

1. 首先 Class 的写法会有特殊内部属性标记[[FunctionKind]]:"classConstructor"，这个标记了，如果没有 `new`，则无法调用类构造函数
2. 类方法是不可枚举的
3. Class 是使用严格模式的

此外，我们需要了解一下 Class 写法中关键 `super`、`static`、`constructor`、`new.target`。本文不做详细介绍。

## 2. 浏览器

### 2.1 浏览器的储存

**cookie**，**localStorage**，**sessionStorage.IndexedDB**

1. **传递方式**：

   1. cookie 在浏览器和服务器间来回传递；
   2. sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存；

2. **存储大小**：
   1. cookie<4K；（ie 内核浏览器占主流地位，且 ie6 仍占有相当大的市场份额，所以在程序中应当使用少于 20 个 cookie，且不大于 4k）
   2. localStorage<=5M；
   3. sessionStorage<=5M；
3. **有效性**：
   1. cookie：只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭也不会消失；
   2. localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；
   3. sessionStorage：仅在当前浏览器窗口关闭前有效，不能持久保持；
4. **共享机制**：
   1. cookie：在所有同源窗口中都是共享的
   2. localStorage ：在所有同源窗口中都是共享的；
   3. sessionStorage：同时“独立”打开的不同窗口，即使是同一页面，sessionStorage 对象也是不同的
5. **浏览器支持**：
   1. sessionStorage 的浏览器最小版本：IE8、Chrome 5。
6. **使用场景**
   1. cookie：保存回话信息
   2. localStorage：持久保存的数据
   3. sessionStorage：拥有独立特性的数据

### 2.2 浏览器的缓存

#### Service Worker 是运行在浏览器背后的独立线程。 必须 HTTPS。

三个步奏：注册（下载：sw.js），监听（等其他 worker 失效），查看缓存

1. sw 线程能够用来和服务器沟通数据（service worker 的上下文内置了 fetch 和 Push API）
2. 能够用来进行大量复杂的运算而不影响 UI 响应。
3. 它能拦截所有的请求

#### Memory Cache

Memory Cache 将资源缓存在了内存中。事实上，所有的网络请求都会被浏览器缓存到内存中，当然，内存容量有限，缓存不能无限存放在内存中，因此，注定是个短期缓存。 内存缓存的控制权在浏览器，前后端都不能干涉。

#### Disk Cache

存储在硬盘中的缓存
强缓存和协商缓存， HTTP Header 来实现的。
Cache-Control > Expires(http1.0 产物, 受本地时间影响) > ETag(http1.1 出现) > Last-Modified（Last-Modified 打开文件的时候会变，以秒计算的）

#### Push Cache

服务器推送，http2

### 2.3 浏览器的渲染

- 生成 dom 树： 字节数据-->字符串-->标记（token）-->node-->dom
- 生成 css 树： 字节数据-->字符串-->标记（token）-->node-->cssdom

#### 整体的渲染过程：

1. 处理 HTML 并构建 DOM 树。
2. 处理 CSS 构建 CSSOM 树。
3. 将 DOM 与 CSSOM 合并成一个渲染树。
4. 根据渲染树来布局，计算每个节点的位置。
5. 调用 GPU 绘制，合成图层，显示在屏幕上。

#### 两个重要的概念，重绘与回流：

- **重绘**：当节点需要更改外观而不会影响布局的，比如改变 `color` 就叫称为重绘
- **回流**：布局或者几何属性需要改变就称为回流。**回流必定会发生重绘，重绘不一定会引发回流**。 回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。

##### 导致性能问题：

1. 改变 window 大小
2. 改变字体
3. 添加或删除样式
4. 文字改变
5. 定位或者浮动
6. 盒模型

##### 减少重绘和回流的细节：

1. 使用 `translate` 替代 `top`

2. 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）
3. 尽量算出结果再去重绘把 DOM 离线后修改，比如：先把 DOM 给 `display:none` (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来
4. 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame Load` 和 `DOMContentLoaded` 区别。`Load` 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。`DOMContentLoaded` 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。

### 2.4 浏览器的安全

1.** xss 跨站脚本攻击**，原理：

1.  构造 URL
2.  发布内容式
3.  蠕虫式
4.  **CSRF 跨站请求伪造**
    1.  验证码。
    2.  HTTP Referer 是 header 的一部分
    3.  token
5.  **sql 脚本注入拼接脚本**
6.  **上传漏洞**
    1.  检查服务器是否判断了上传文件类型及后缀。
    2.  定义上传文件类型白名单，即只允许白名单里面类型的文件上传。
    3.  文件上传目录禁止执行脚本解析，避免攻击者进行二次攻击。

### 2.5 浏览器的跨域

首先什么是跨域，违反浏览器**同源策略**的就是跨域。跨域本身就是就是为了保护浏览器的安全， 主要是用来**防止 CSRF 攻击的**

那什么是同源策略？所谓的同源，指的是**协议**，**域名**，**端口相同**。浏览器处于安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，在没有明确授权的情况下，不能读写对方的资源。

解决同源策略的方案：

1. sonp
2. iframe
3. postMessage
4. CORS
5. webscoket
6. 反向代理服务器

### 2.6 浏览器的内存

浏览器（通常指）的内存分配，64 位系统下大约为 1.4GB，在 32 位系统下大约为 0.7G。

我们通常定义变量时候就完成了分配内存，使用时候是对内存的读写操作，内存的释放依赖于浏览器的**垃圾回收机制**

#### 造成内存泄露

1. 意外的全局变量引起的内存泄漏。

2. 闭包引起的内存泄漏
3. 没有清理的 DOM 元素引用
4. 被遗忘的定时器或者回调
5. 监听事件

### 2.7 浏览器的垃圾回收

64 位下新生代的空间为 64M，老生代为 1400M 32 位下新生代的空间为 16M，老生代为 700M.

javaScript 使用垃圾回收机制来自动管理内存，垃圾回收是一把双刃剑

- **优势**：可以大幅度简化程序的内存管理代码，降低程序的负担，减少因时常运转而带来的内存泄露问题。
- **劣势**：意味着程序员将无法掌控内存。js 没有暴露任何关于内存的 API。我们无法强迫其进行垃圾回收，也无法干预内存管理。

1. V8 最初是为了浏览器设计的，不太可能遇到大内存的场景
2. js 垃圾回收的时候程序会暂停线程执行，会占用一定时间。

它有两种情况会回收，一种是定时回收，一种内存不够了回收。

1. 新生代算法 Scavenge GC（GC 复制算法） 分为两个空间：form 跟 to。
2. 老生代算法 标记清除算法 标记压缩算法

[垃圾回收机制](https://www.jianshu.com/p/a8a04fd00c3c)

### 2.8 浏览器的执行机制

javascript 是一门**单线程语言**， `Event Loop` 是 javascript 的执行机制 libuv
[需明白什么叫事件循环事件，微任务，宏任务。以及如何运行。](https://juejin.im/post/6844903613169401869#heading-2)

# 三. 巩固前端基建

## 1. 加深巩固篇

### 1.1 前端去重的方法有哪些？

### 1.2 前端异步的方案有哪些？

### 1.3 前端网络请求有哪些？

### 1.4 前端定时器有哪些？

### 1.5 前端创建对象有哪几种方式？

### 1.6 前端代码的复用有哪几种方式？

## 2. 工具拓展篇

### 2.1 webpack

### 2.2 nginx

### 2.3 csr 与 ssr

### 2.4 web Worker

## 3. 网络协议篇

TCP 三次握手，DNS 解析...

## 4. 设计模式篇

单例模式，观察者模式....

## 5. 前端算法篇

排序算法等...

# 四. 手写原生代码

apply, call, bind, new...

# 五. 前端框架

## 1. Vue

mvvn，数据劫持，router，vuex...

## 2. React

redux，hooks...

## 3. 小程序

自定义组件，生命周期...

## 4. hybrid app

# 六. 前端性能

## 1. 如何跟踪

perfomance lighthouse...

## 2. 如何优化

从网络出发，从渲染出发...

# 七. 前端素养

```

```
